// @flow
import createFactory, { createGetInitialState, type BoilerState } from './factory';

export type MapState<T> = { [string]: BoilerState<T> };

/** A redux-boilerplate maker for loading data by keys
 * This generator uses the other generator, and creates new reducers as necessary to store
 * new calls to the load method. You can query the meta data by the same arguments, which
 * means that you can easily prevent reloading data or viewing meta data about loads.

 ** Example:
 * Pass a `load` function in:
```js
 const { action: { load }, getters: { getData, getMeta } } =
   factory({ fetchData: Function })

 // Somewhere else, maybe in a component

 ...
 componentDidMount() {
   const { loaded, taskId, userId } = this.props;
   !loaded && load(userId, taskId);
 }
 ...
 mapStateToProps(state, props) {
   const { userId, taskId } = props;
   return {
     loaded: getMeta(userId, taskId).loaded,
     taskData: getData(userId, taskId)
   }
 }
 ```

 * Configuration Parameters
 * @param name - String that identifies the data being stored
 * @param fetchData - An async method that loads the data, params are used as a Stringified key for the map
 * @param getInitialState - Set the default value for the fetchData function in the store. Defaults to null
 * */

type ReturnType<T, G: Array<mixed>> = {
  actions: * & {
    reset: () => *,
    clearErrors: () => *,
    load: (...args: G) => *,
  },
  getters: * & {
    get: Object => MapState<T>,
    getWithArgs: (store: Object, ...args: Array<mixed>) => BoilerState<T>,
    getData: (store: Object, ...args: Array<mixed>) => $PropertyType<BoilerState<T>, 'data'>,
    getMeta: (store: Object, ...args: Array<mixed>) => $PropertyType<BoilerState<T>, 'meta'>,
    getIsLoading: (
      store: Object,
      ...args: Array<mixed>
    ) => $PropertyType<$PropertyType<BoilerState<T>, 'meta'>, 'loading'>,
  },
};

let generatedCount = 0;

const convertArgsToString = (...args) => JSON.stringify(args);

const createFactoryMap = (injectReducer: Function) => {
    const factory = createFactory(injectReducer);
    return <T, G: Array<mixed>>(config: {
  name?: string,
  fetchData?: (...args: G) => T | Promise<T>,
  getInitialState?: () => T,
}): ReturnType<T, G> => {
  const { name = '', fetchData, getInitialState } = config;
  generatedCount += 1;

  const safeDataName = `${name}_${generatedCount}`;
  const mapArgsToGenerated = {};

  class Getters {
    static _getInitialStateForKey: () => BoilerState<T> = createGetInitialState(getInitialState);

    static get = (reduxStore: Object): MapState<T> =>
      reduxStore.generatedMap && reduxStore.generatedMap[safeDataName];

    static getWithArgs = (reduxStore, ...args) => {
      const argsKey = convertArgsToString(...args);
      const state = Getters.get(reduxStore);
      if (!state || !state.hasOwnProperty(argsKey)) {
        return Getters._getInitialStateForKey();
      }
      return state[argsKey];
    };

    static getData = (reduxStore, ...args) => Getters.getWithArgs(reduxStore, ...args).data;

    static getMeta = (reduxStore, ...args) => Getters.getWithArgs(reduxStore, ...args).meta;

    static getIsLoading = (reduxStore: Object, ...args) => {
      const meta = Getters.getMeta(reduxStore, ...args);
      return meta.loading;
    };
  }

  const queryOrCreateBoilerplate = (...args) => {
    const stringHash = convertArgsToString(...args);
    if (!mapArgsToGenerated[stringHash]) {
      // Need to generate everything for this. Luckily we have a generator
      const getOutOfStore: any = store => Getters.getWithArgs(store, ...args);
      mapArgsToGenerated[stringHash] = factory({
        name: safeDataName,
        fetchData,
        getInitialState,
        getInStore: getOutOfStore,
      });
      const subreducer = mapArgsToGenerated[stringHash].subreducer.subreduce;
      injectReducer(['generatedMap', safeDataName, stringHash], subreducer);
    }
    return mapArgsToGenerated[stringHash];
  };

  class Actions {
    // Links to argument-less actions generated by the factory.
    static _forwardActionForSubreducer = (actionName: string, { forwardArgs = false }: * = {}) => (
      ...args: Array<mixed>
    ) => async dispatch => {
      const actions = queryOrCreateBoilerplate(...args).actions;
      const action = actions[actionName];
      if (forwardArgs) {
        return dispatch(action(...args)); // Assumed to be loading arguments.
      }
      return dispatch(action());
    };

    static load = Actions._forwardActionForSubreducer('load', { forwardArgs: true });

    static reset = Actions._forwardActionForSubreducer('reset');

    static clearErrors = Actions._forwardActionForSubreducer('clearErrors');
  }

  return {
    actions: Actions,
    getters: Getters,
  };
};
}

export default createFactoryMap;

