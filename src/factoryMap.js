// @flow
import createFactory, { createGetInitialState, type BoilerState } from './factory';

export type MapState<T> = { [string]: BoilerState<T> };

type ConfigType<T, G> = {
  name?: string,
  fetchData?: (...args: G) => T | Promise<T>,
  getInitialState?: () => T,
};

type ReturnType<T, G: Array<mixed>> = {
  actions: * & {
    reset: () => *,
    clearErrors: () => *,
    load: (...args: G) => *,
  },
  getters: * & {
    get: Object => MapState<T>,
    getWithArgs: (store: Object, ...args: Array<mixed>) => BoilerState<T>,
    getData: (store: Object, ...args: Array<mixed>) => $PropertyType<BoilerState<T>, 'data'>,
    getMeta: (store: Object, ...args: Array<mixed>) => $PropertyType<BoilerState<T>, 'meta'>,
    getIsLoading: (
      store: Object,
      ...args: Array<mixed>
    ) => $PropertyType<$PropertyType<BoilerState<T>, 'meta'>, 'loading'>,
  },
};

let generatedCount = 0;

const convertArgsToString = (...args) => JSON.stringify(args);

const createFactoryMap = (injectReducer: Function) => {
    const factory = createFactory(injectReducer);
    return <T, G: Array<mixed>>(config: ConfigType<T, G>): ReturnType<T, G> => {
      const { name = '', fetchData, getInitialState } = config;
      generatedCount += 1;

      const safeDataName = `${name}_${generatedCount}`;
      const mapArgsToGenerated = {};

      class Getters {
        static _getInitialStateForKey: () => BoilerState<T> = createGetInitialState(getInitialState);

        static get = (reduxStore: Object): MapState<T> =>
          reduxStore.generatedMap && reduxStore.generatedMap[safeDataName];

        static getWithArgs = (reduxStore, ...args) => {
          const argsKey = convertArgsToString(...args);
          const state = Getters.get(reduxStore);
          if (!state || !state.hasOwnProperty(argsKey)) {
            return Getters._getInitialStateForKey();
          }
          return state[argsKey];
        };

        static getData = (reduxStore, ...args) => Getters.getWithArgs(reduxStore, ...args).data;

        static getMeta = (reduxStore, ...args) => Getters.getWithArgs(reduxStore, ...args).meta;

        static getIsLoading = (reduxStore: Object, ...args) => {
          const meta = Getters.getMeta(reduxStore, ...args);
          return meta.loading;
        };
      }

      const queryOrCreateBoilerplate = (...args) => {
        const stringHash = convertArgsToString(...args);
        if (!mapArgsToGenerated[stringHash]) {
          // Need to generate everything for this. Luckily we have a generator
          const getOutOfStore: any = store => Getters.getWithArgs(store, ...args);
          mapArgsToGenerated[stringHash] = factory({
            name: safeDataName,
            fetchData,
            getInitialState,
            getInStore: getOutOfStore,
          });
          const subreducer = mapArgsToGenerated[stringHash].subreducer.subreduce;
          injectReducer(['generatedMap', safeDataName, stringHash], subreducer);
        }
        return mapArgsToGenerated[stringHash];
      };

      class Actions {
        // Links to argument-less actions generated by the factory.
        static _forwardActionForSubreducer = (actionName: string, { forwardArgs = false }: * = {}) => (
          ...args: Array<mixed>
        ) => async dispatch => {
          const actions = queryOrCreateBoilerplate(...args).actions;
          const action = actions[actionName];
          if (forwardArgs) {
            return dispatch(action(...args)); // Assumed to be loading arguments.
          }
          return dispatch(action());
        };

        static load = Actions._forwardActionForSubreducer('load', { forwardArgs: true });

        static reset = Actions._forwardActionForSubreducer('reset');

        static clearErrors = Actions._forwardActionForSubreducer('clearErrors');
      }

      return {
        actions: Actions,
        getters: Getters,
      };
    };
  };

export default createFactoryMap;

